<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>spring面试整理 | Hexo</title>
  <meta name="description" content="spring面试整理1. Spring框架概述1.1 什么是spring框架？Spring框架有哪些主要模块？Spring框架是一个为 Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员专注于应用程序的开发。 Spring框架本身亦是按照设计模式精心打造，这使得我们可以 在开发环境中安心I的集成Spring框架，不必担心S">
<meta property="og:type" content="article">
<meta property="og:title" content="spring面试整理">
<meta property="og:url" content="http://fyvan.github.io/undefined/e999.html">
<meta property="og:site_name" content="Yvan Blog">
<meta property="og:description" content="spring面试整理1. Spring框架概述1.1 什么是spring框架？Spring框架有哪些主要模块？Spring框架是一个为 Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员专注于应用程序的开发。 Spring框架本身亦是按照设计模式精心打造，这使得我们可以 在开发环境中安心I的集成Spring框架，不必担心S">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://fyvan.github.io/undefined/images/loading.gif">
<meta property="og:image" content="http://fyvan.github.io/undefined/images/loading.gif">
<meta property="og:image" content="http://fyvan.github.io/undefined/images/loading.gif">
<meta property="og:image" content="http://fyvan.github.io/undefined/images/loading.gif">
<meta property="article:published_time" content="2020-06-15T02:08:06.870Z">
<meta property="article:modified_time" content="2020-06-18T06:59:49.500Z">
<meta property="article:author" content="Yvan Yang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fyvan.github.io/undefined/images/loading.gif">
  <!-- Canonical links -->
  <link rel="canonical" href="http://fyvan.github.io/undefined/e999.html">
  
    <link rel="alternate" href="/atom.xml" title="Yvan Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="./images/loading.gif" data-original="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">昵称</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/API/">API</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MYSQL/">MYSQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Project/">Project</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Software-Install/">Software_Install</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cate1/">cate1</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cate1/cate2/">cate2</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/software/">software</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/synchronized/">synchronized</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS7-Nginx/" rel="tag">CentOS7, Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS7-Redis/" rel="tag">CentOS7, Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS7-jdk1-8/" rel="tag">CentOS7, jdk1.8</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS7-mariadb/" rel="tag">CentOS7, mariadb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ObjectMapper/" rel="tag">ObjectMapper</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Project/" rel="tag">Project</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/" rel="tag">SpringMVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubantu-MongoDB/" rel="tag">Ubantu,MongoDB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/" rel="tag">Zookeeper</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keyword1-keyword2/" rel="tag">keyword1,keyword2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized/" rel="tag">synchronized</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/CentOS7-Nginx/" style="font-size: 13px;">CentOS7, Nginx</a> <a href="/tags/CentOS7-Redis/" style="font-size: 13px;">CentOS7, Redis</a> <a href="/tags/CentOS7-jdk1-8/" style="font-size: 13px;">CentOS7, jdk1.8</a> <a href="/tags/CentOS7-mariadb/" style="font-size: 13px;">CentOS7, mariadb</a> <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/MySql/" style="font-size: 13px;">MySql</a> <a href="/tags/ObjectMapper/" style="font-size: 13px;">ObjectMapper</a> <a href="/tags/Project/" style="font-size: 13px;">Project</a> <a href="/tags/SpringMVC/" style="font-size: 13px;">SpringMVC</a> <a href="/tags/Ubantu-MongoDB/" style="font-size: 13px;">Ubantu,MongoDB</a> <a href="/tags/Zookeeper/" style="font-size: 13px;">Zookeeper</a> <a href="/tags/keyword1-keyword2/" style="font-size: 13px;">keyword1,keyword2</a> <a href="/tags/redis/" style="font-size: 13px;">redis</a> <a href="/tags/synchronized/" style="font-size: 13px;">synchronized</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 14px;">面试</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">10</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/undefined/e999.html" class="title">spring面试整理</a>
              </p>
              <p class="item-date">
                <time datetime="2020-06-15T02:08:06.870Z" itemprop="datePublished">2020-06-15</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
              </p>
              <p class="item-title">
                <a href="/undefined/1529.html" class="title">面试之性能优化</a>
              </p>
              <p class="item-date">
                <time datetime="2020-06-13T00:46:31.457Z" itemprop="datePublished">2020-06-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
              </p>
              <p class="item-title">
                <a href="/undefined/1529.html" class="title">面试之性能优化</a>
              </p>
              <p class="item-date">
                <time datetime="2020-06-10T11:30:08.440Z" itemprop="datePublished">2020-06-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Project/">Project</a>
              </p>
              <p class="item-title">
                <a href="/undefined/af36.html" class="title">项目业务实现</a>
              </p>
              <p class="item-date">
                <time datetime="2020-06-09T11:07:05.370Z" itemprop="datePublished">2020-06-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/redis/">redis</a>
              </p>
              <p class="item-title">
                <a href="/undefined/776d.html" class="title">Redis常见的性能问题</a>
              </p>
              <p class="item-date">
                <time datetime="2020-06-09T00:38:57.562Z" itemprop="datePublished">2020-06-09</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-spring面试整理" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      spring面试整理
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/undefined/e999.html" class="article-date">
	  <time datetime="2020-06-15T02:08:06.870Z" itemprop="datePublished">2020-06-15</time>
	</a>
</span>
        
        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/undefined/e999.html#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="spring面试整理"><a href="#spring面试整理" class="headerlink" title="spring面试整理"></a>spring面试整理</h1><h2 id="1-Spring框架概述"><a href="#1-Spring框架概述" class="headerlink" title="1. Spring框架概述"></a>1. Spring框架概述</h2><h3 id="1-1-什么是spring框架？Spring框架有哪些主要模块？"><a href="#1-1-什么是spring框架？Spring框架有哪些主要模块？" class="headerlink" title="1.1 什么是spring框架？Spring框架有哪些主要模块？"></a>1.1 什么是spring框架？Spring框架有哪些主要模块？</h3><p>Spring框架是一个为 Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员专注于应用程序的开发。</p>
<p>Spring框架本身亦是按照设计模式精心打造，这使得我们可以 在开发环境中安心I的集成Spring框架，不必担心Spring是如何在后台进行工作的。Spring框架至今已经集成了20多个模块。这些模块主要被分为如下图所示的核心容器、数据访问/集成、Web、AOP（面向切面编程）、工具、消息、和测试模块。</p>
<p><img src="./images/loading.gif" data-original="../images/posts/spring%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/5-1Z606104H1294.jpg" alt=""></p>
<h4 id="1-1-1-Data-Access-Integration-数据访问-集成）"><a href="#1-1-1-Data-Access-Integration-数据访问-集成）" class="headerlink" title="1.1.1 Data Access/Integration(数据访问/集成）"></a>1.1.1 Data Access/Integration(数据访问/集成）</h4><p>数据访问/集成层包括JDBC、ORM、OXM、JMS、和Transaction模块，具体介绍如下：</p>
<ul>
<li>JDBC模块：提供了一个JDBC的抽象层，大幅度减少了在开发过程中能够对数据库操作的编码。</li>
<li>ORM模块：对流行的对象关系 映射API，包括JPA、JDO、Hibernate和iBatis提供了集成层。</li>
<li>OXM模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。</li>
<li>JMS模块：指 <a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a> 消息服务，包含的功能为生产和消费的信息。</li>
<li>Transactions事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。</li>
</ul>
<h4 id="1-1-2-Web-模块"><a href="#1-1-2-Web-模块" class="headerlink" title="1.1.2 Web 模块"></a>1.1.2 Web 模块</h4><p>Spring 的 Web 层包括 Web、<a href="http://c.biancheng.net/servlet/" target="_blank" rel="noopener">Servlet</a>、Struts 和 Portlet 组件，具体介绍如下。</p>
<ul>
<li>Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。</li>
<li>Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web 应用程序。</li>
<li>Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。</li>
<li>Portlet 模块：提供了在 Portlet 环境中使用 MV C实现，类似 Web-Servlet 模块的功能。</li>
</ul>
<h4 id="1-1-3-Core-Container（核心容器）"><a href="#1-1-3-Core-Container（核心容器）" class="headerlink" title="1.1.3 Core Container（核心容器）"></a>1.1.3 Core Container（核心容器）</h4><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成，具体介绍如下。</p>
<ul>
<li>Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。</li>
<li>Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。</li>
<li>Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。</li>
<li>Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。</li>
</ul>
<h4 id="1-1-4-其他模块"><a href="#1-1-4-其他模块" class="headerlink" title="1.1.4 其他模块"></a>1.1.4 其他模块</h4><p>Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下。</p>
<ul>
<li>AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。</li>
<li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li>
<li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li>
<li>Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。</li>
</ul>
<h3 id="1-2-使用Spring框架能带来哪些好处？"><a href="#1-2-使用Spring框架能带来哪些好处？" class="headerlink" title="1.2 使用Spring框架能带来哪些好处？"></a>1.2 使用Spring框架能带来哪些好处？</h3><p>下面列举一些使用Spring框架带来的主要好处：</p>
<ul>
<li>Dependency Injection（DI）方法使得构造器和JavaBean properties文件 中的依赖关系一目了然。</li>
<li>与EJB容器相比较，IoC同期更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。</li>
<li>Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer,以及 其他视图技术。</li>
<li>Spring框架是按照模块的形式来组织的。又包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li>要测试一项用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。</li>
<li>SPring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架以外的有力选项。</li>
<li>Spring提供了一个便捷的事务管理接口，适用于小型的本地事务处理（比如在单DB的环境下）和复杂的共同事务处理（比如利用JTA的复杂DB环境）。</li>
</ul>
<h3 id="1-3-Spring框架的设计目标，设计理念，和核心是什么？"><a href="#1-3-Spring框架的设计目标，设计理念，和核心是什么？" class="headerlink" title="1.3 Spring框架的设计目标，设计理念，和核心是什么？"></a>1.3 Spring框架的设计目标，设计理念，和核心是什么？</h3><p><code>Spring设计目标</code>：spring为开发者提供一个一站式情况及应用开发平台。</p>
<p><code>Spring设计理念</code>：在JavaEE开发中，支持POJO和JavaBean开发 方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC同期实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦。</p>
<p><code>Spring框架的核心</code>：IoC容器和AOP模块。通过IoC同期关机POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p>
<p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p>
<h3 id="1-4-Spring的优缺点是什么？"><a href="#1-4-Spring的优缺点是什么？" class="headerlink" title="1.4 Spring的优缺点是什么？"></a>1.4 Spring的优缺点是什么？</h3><p><code>优点：</code></p>
<ul>
<li><p>方便解耦，简化开发</p>
<p>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p>
</li>
<li><p>AOP编程的支持</p>
<p>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>
</li>
<li><p>声明式事务的支持</p>
<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>
</li>
<li><p>方便程序的测试</p>
<p>Spring对Junit4/5支持，可以通过注解方便的测试Spring程序。</p>
</li>
<li><p>方便集成各种优秀框架</p>
<p>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架直接支持（如：Struts、Hibernate、MyBatista等）。</p>
</li>
<li><p>降低JavaEE API的使用难度</p>
<p>Spring对JavaEE开发中非常刊用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使用 这些API应用难度大大降低。</p>
</li>
</ul>
<p><code>缺点：</code></p>
<ul>
<li>Spring明明是一个很轻量级的框架，却给人感觉很大而全</li>
<li>Spring依赖反射，反射影响性能</li>
<li>使用门槛升高，入门Spring需要较长时间</li>
</ul>
<h3 id="1-5-Spring有哪些应用场景"><a href="#1-5-Spring有哪些应用场景" class="headerlink" title="1.5 Spring有哪些应用场景"></a>1.5 Spring有哪些应用场景</h3><p>应用场景：JavaEE企业应用开发，包括SSH、SSM等</p>
<p><strong>Spring价值</strong>：</p>
<ul>
<li>Spring是一个非侵入式的框架，目标是使应用程序代码对框架依赖最小化。</li>
<li>Spring提供一个一致的编程模型，使应用直接使用 POJO开发，于运行环境隔离开来。</li>
<li>Spring推动应用设计风格面向对象和面向接口开发转变，提高了代码的重用性和可测试性。</li>
</ul>
<h3 id="1-6-Spring框架中都用到了哪些设计模式？"><a href="#1-6-Spring框架中都用到了哪些设计模式？" class="headerlink" title="1.6 Spring框架中都用到了哪些设计模式？"></a>1.6 Spring框架中都用到了哪些设计模式？</h3><ol>
<li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例</li>
<li>单利模式：Bean默认为单利模式</li>
<li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术</li>
<li>模板方法：用来解决代码重复的问题。比如：RestTemplate，JmsTemplate,JpaTemplate</li>
<li>观察者模式：定义对象键一种一对多的 依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被自动更新，如Spring种listener的实现–ApplicationListener。</li>
</ol>
<h3 id="1-7-详细讲解一下核心容器（Spring-context应用上下文）模块"><a href="#1-7-详细讲解一下核心容器（Spring-context应用上下文）模块" class="headerlink" title="1.7 详细讲解一下核心容器（Spring context应用上下文）模块"></a>1.7 详细讲解一下核心容器（Spring context应用上下文）模块</h3><p>这是基本的Spring模块，提供Spring框架的基础功能，BeanFactory是任何以Spring为基础的应用的核心。Spring框架建立在此模块之上，它使Spring成为一个容器。</p>
<p>Bean工厂是工厂模式的一个实现，提供弄个了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据 XML文件总定义加载beans。该同期从XML文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p>
<h3 id="1-8-Spring框架中有哪些不同类型的事件"><a href="#1-8-Spring框架中有哪些不同类型的事件" class="headerlink" title="1.8 Spring框架中有哪些不同类型的事件"></a>1.8 Spring框架中有哪些不同类型的事件</h3><p>Spring提供了一下5中标准的事件：</p>
<ol>
<li><code>上下文更新事件(ContextRefreshedEvent)</code>：在 调用ConfigurableApplicationContext接口中的refresh（）方法时被触发。</li>
<li><code>上下文开始事件（ContextStartedEvent）</code>：当容器调用ConfigurableApplicationContext的Start（）方法开始/重新开始容器时触发该事件。</li>
<li><code>上下文停止事件（ContextStoppedEvent）</code>：当容器调用ConfigurableApplicationContext的Stop（）方法停止容器时触发该事件。</li>
<li><code>上下文关闭事件(ContextClosedEvent)</code>：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单利Bean都被销毁。</li>
<li><code>请求处理事件(RequestHandledEvent)</code>：在 Web应用中，当HTTP请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent被发布以后，bean会自动被通知。</li>
</ol>
<h3 id="1-9-Spring应用程序有哪些不同组件？"><a href="#1-9-Spring应用程序有哪些不同组件？" class="headerlink" title="1.9 Spring应用程序有哪些不同组件？"></a>1.9 Spring应用程序有哪些不同组件？</h3><p>Spring应用一般有以下组件：</p>
<ul>
<li>接口 - 定义功能</li>
<li>Bean类 - 它包含属性，setter和getter方法，函数等</li>
<li>Bean配置文件 - 包含类的信息以及如何配置他们。</li>
<li>Spring面向切面编程(AOP) - 提供面向切面编程的功能</li>
<li>用户程序 - 它使用接口</li>
</ul>
<h3 id="1-10-使用Spring有哪些方式？"><a href="#1-10-使用Spring有哪些方式？" class="headerlink" title="1.10 使用Spring有哪些方式？"></a>1.10 使用Spring有哪些方式？</h3><p>使用Spring有以下方式：</p>
<ul>
<li>作为一个成熟的Spring Web应用程序</li>
<li>作为第三方Web框架，使用Spring Frameworks中间层</li>
<li>最为企业级Java Bean，他可以保障现有的POJO（Plain Old Java Object）</li>
<li>用于远程使用</li>
</ul>
<h2 id="2-Spring控制反转-IoC-和依赖注入-DI"><a href="#2-Spring控制反转-IoC-和依赖注入-DI" class="headerlink" title="2. Spring控制反转(IoC)和依赖注入(DI)"></a>2. Spring控制反转(IoC)和依赖注入(DI)</h2><h3 id="2-1-什么是-Spring-IoC容器"><a href="#2-1-什么是-Spring-IoC容器" class="headerlink" title="2.1 什么是 Spring IoC容器"></a>2.1 什么是 Spring IoC容器</h3><p>控制反转即IoC(Inversion of Control),它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p>
<p>Spring IoC负责创建对象，管理对象(通过依赖注入 DI)，装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<h3 id="2-2-控制反转-IoC-有什么作用？"><a href="#2-2-控制反转-IoC-有什么作用？" class="headerlink" title="2.2 控制反转(IoC)有什么作用？"></a>2.2 控制反转(IoC)有什么作用？</h3><ul>
<li>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事情，在对象关系比较复杂时，如果依赖关系需要程序员来维护的话，那是相当头疼的</li>
<li>解耦，由容器去维护具体的对象</li>
<li>托管了类的生产过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li>
</ul>
<h3 id="2-3-IoC的优点是什么？"><a href="#2-3-IoC的优点是什么？" class="headerlink" title="2.3 IoC的优点是什么？"></a>2.3 IoC的优点是什么？</h3><ul>
<li>IoC或依赖注入把应用的代码量降低到最低</li>
<li>它使应用程序容易测试，单元测试不再需要单例和JNDI查找机制</li>
<li>最小的代价阿和最小的侵入性使松散耦合得以实现。</li>
<li>IoC容器支持加载服务时的饿汉式初始化和懒加载。</li>
</ul>
<h3 id="2-4-Spring-IoC的实现机制"><a href="#2-4-Spring-IoC的实现机制" class="headerlink" title="2.4 Spring IoC的实现机制"></a>2.4 Spring IoC的实现机制</h3><p><code>Spring 中的IoC的实现原理就是工厂模式和反射机制**</code></p>
<p>示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Fruit</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">implements</span> <span class="token class-name">Fruit</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Orange</span> <span class="token keyword">implements</span> <span class="token class-name">Fruit</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Factory</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span>  Fruit <span class="token function">getInstance</span><span class="token punctuation">(</span>String ClassName<span class="token punctuation">)</span><span class="token punctuation">{</span>
        Furit f <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            f <span class="token operator">=</span> <span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>ClassName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> f<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Client</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
        Furit f <span class="token operator">=</span> Factory<span class="token punctuation">.</span><span class="token function">getIntence</span><span class="token punctuation">(</span><span class="token string">"io.github.dunwu.spring.Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>f <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
            f<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="2-5-Spring-的IoC支持哪些功能？"><a href="#2-5-Spring-的IoC支持哪些功能？" class="headerlink" title="2.5 Spring 的IoC支持哪些功能？"></a>2.5 Spring 的IoC支持哪些功能？</h3><p>Spring的IoC设计支持以下功能：</p>
<ul>
<li>依赖注入</li>
<li>依赖检查</li>
<li>自动装配</li>
<li>支持集合</li>
<li>指定初始化方法和销毁方法</li>
<li>支持回调某些方法（但是需要实现Spring接口，略有侵入）</li>
</ul>
<p>其中，最重要的就是依赖注入，从XML的配置上说，即ref标签。对应Spring RuntimeBeanReference对象。</p>
<p>对于IoC来说，最重要就是容器。容器管理着Bean的生命周期，控制着Bean的依赖注入。</p>
<h3 id="2-6-BeanFactory和ApplicationContext有什么区别？"><a href="#2-6-BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="2.6 BeanFactory和ApplicationContext有什么区别？"></a>2.6 BeanFactory和ApplicationContext有什么区别？</h3><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationCont是BeanFactory的子接口。</p>
<p><code>依赖关系</code></p>
<p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化、控制bean的生命周期，维护bean之间的依赖关系。</p>
<p>ApplicationContext接口 作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li>集成MessageSource，因此支持国际化</li>
<li>同意的资源文件访问当时</li>
<li>提供在监听器中注册bean的事件</li>
<li>同时加载多个配置 文件</li>
<li>载入多个（有继承关系 ）上下文，使得每一个上下文都专注于一个特定的层次，比如应用的web层</li>
</ul>
<p><code>加载方式</code></p>
<p>BeanFactory采用的是延迟加载形式来注入Bean的，即只有在 使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFactory加载后，直至第一次使用掉哦弄getBean方法才会抛出异常。</p>
<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖的属性是否注入。ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean，确保当你需要的时候，你就不用等待，因为他们已经创建好了。</p>
<p>相对于基本的BeanFactory，ApplicationContext唯一的不足时占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p>
<p><code>创建方式</code></p>
<p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p>
<p><code>注册方式</code></p>
<p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<h3 id="2-7-Spring如何设计容器的，BeanFactory和ApplicationContext的关系详解"><a href="#2-7-Spring如何设计容器的，BeanFactory和ApplicationContext的关系详解" class="headerlink" title="2.7 Spring如何设计容器的，BeanFactory和ApplicationContext的关系详解"></a>2.7 Spring如何设计容器的，BeanFactory和ApplicationContext的关系详解</h3><p>Spring作者Rod Johnson设计了两届接口用以表示容器</p>
<ul>
<li>BeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>BeanFactory简单粗暴，可以理解为就是个HashMap，key是BeanName，value是Bean实例。通常只提供注册(put)，获取(get)这两个功能。我们介意称之为<strong>“低级容器”</strong>。</p>
<p>ApplicationContext可以称之为<strong>“高级容器”</strong>。应为他比BeanFactory多了更多的功能。它继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息(例如JSP tag的支持)，对BeanFactory多了工具界别的支持等待。所以你看他的名字已经不是BeanFactory之类的工厂了，而是“应用上下文”，代表着整个大容器的所有功能。该接口定义了一个refresh方法，此方法是所有阅读Spring源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的Bean。</p>
<p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p>
<p>BeanFactory和ApplicationContext的关系</p>
<p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。<br><img src="./images/loading.gif" data-original="../images/posts/spring%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/20191105111441363.png" alt=""></p>
<p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p>
<p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p>
<p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p>
<p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p>
<p>小结</p>
<p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p>
<p>加载配置文件，解析成 BeanDefinition 放在 Map 里。</p>
<p>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p>
<p>上面就是 Spring 低级容器（BeanFactory）的 IoC。</p>
<p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p>
<p>#3# 2.8 ApplicationContext通常的实现是什么？</p>
<p><strong><code>FileSystemXmlApplicationContext ：</code></strong>此容器从一个XML文件中加载beans的定义，XML Bean配置文件的全路径名必须提供给它的构造函数。</p>
<p><strong><code>ClassPathXmlApplicationContext：</code></strong>此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p>
<p><strong><code>WebXmlApplicationContext：</code></strong>此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p>
<h3 id="2-9-什么是Spring的依赖注入？"><a href="#2-9-什么是Spring的依赖注入？" class="headerlink" title="2.9 什么是Spring的依赖注入？"></a>2.9 什么是Spring的依赖注入？</h3><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：<code>依赖注入</code>和<code>依赖查找</code></p>
<p>依赖注入：相对于IoC而言，依赖注入(DI)更加准确的描述了IoC的设计理念。所谓依赖注入(Dependency Injection),即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地讲 某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p>
<h3 id="2-10-依赖注入的基本原则"><a href="#2-10-依赖注入的基本原则" class="headerlink" title="2.10 依赖注入的基本原则"></a>2.10 依赖注入的基本原则</h3><p>依赖注入的基本原则是：应用组件不应该负责朝招资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系对象通过属性(JavaBean中的setter)或者构造器传递给需要的对象。</p>
<h3 id="2-11-依赖注入有什么优势"><a href="#2-11-依赖注入有什么优势" class="headerlink" title="2.11 依赖注入有什么优势"></a>2.11 依赖注入有什么优势</h3><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象 的依赖关系。其与依赖查找方式相比，主要优势为：</p>
<ul>
<li>查找定位操作与应用代码完全无关</li>
<li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象</li>
<li>不需要 特殊的接口，绝大多数对象可以做到完全不必依赖容器</li>
</ul>
<h3 id="2-12-依赖注入的实现方式"><a href="#2-12-依赖注入的实现方式" class="headerlink" title="2.12 依赖注入的实现方式"></a>2.12 依赖注入的实现方式</h3><p>依赖注入是时下 最流行的IoC实现方式，依赖注入分为<code>接口注入(Interface Injection)</code>，<code>Setter方法注入(Setter Injection)</code>和<code>构造器注入(Constructor Injection)</code>三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已经被废弃。</p>
<p><strong><code>构造器依赖注入</code></strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<p><strong><code>Setter方法注入</code></strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>
<h3 id="2-13-构造器依赖注入和-Setter方法注入的区别"><a href="#2-13-构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="2.13 构造器依赖注入和 Setter方法注入的区别"></a>2.13 构造器依赖注入和 Setter方法注入的区别</h3><table>
<thead>
<tr>
<th align="center"><strong>构造函数注入</strong></th>
<th align="center"><strong>setter</strong> <strong>注入</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">没有部分注入</td>
<td align="center">有部分注入</td>
</tr>
<tr>
<td align="center">不会覆盖 setter 属性</td>
<td align="center">会覆盖 setter 属性</td>
</tr>
<tr>
<td align="center">任意修改都会创建一个新实例</td>
<td align="center">任意修改不会创建一个新实例</td>
</tr>
<tr>
<td align="center">适用于设置很多属性</td>
<td align="center">适用于设置少量属性</td>
</tr>
</tbody></table>
<p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖</p>
<h2 id="3-Spring-Beans"><a href="#3-Spring-Beans" class="headerlink" title="3. Spring Beans"></a>3. Spring Beans</h2><h3 id="3-1-什么是Spring-Beans"><a href="#3-1-什么是Spring-Beans" class="headerlink" title="3.1 什么是Spring Beans?"></a>3.1 什么是Spring Beans?</h3><p>Spring Beans是那些形成Spring应用的主干的java对象。它们被Spring IoC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中的形式定义。</p>
<h3 id="3-2-一个Spring-Bean定义包含什么？"><a href="#3-2-一个Spring-Bean定义包含什么？" class="headerlink" title="3.2 一个Spring Bean定义包含什么？"></a>3.2 一个Spring Bean定义包含什么？</h3><p>一个Spring Bean的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。 </p>
<h3 id="3-3-如何给Spring容器提供配置元数据？Spring有几种配置方式？"><a href="#3-3-如何给Spring容器提供配置元数据？Spring有几种配置方式？" class="headerlink" title="3.3 如何给Spring容器提供配置元数据？Spring有几种配置方式？"></a>3.3 如何给Spring容器提供配置元数据？Spring有几种配置方式？</h3><p>这里有三种重要的方法给Spring容器提供配置元数据。</p>
<ul>
<li>XML配置文件</li>
<li>基于注解的配置</li>
<li>基于java的配置</li>
</ul>
<h3 id="3-4-Spring配置文件中包含了哪些信息"><a href="#3-4-Spring配置文件中包含了哪些信息" class="headerlink" title="3.4 Spring配置文件中包含了哪些信息"></a>3.4 Spring配置文件中包含了哪些信息</h3><p>Spring配置文件是个XML文件，这个文件包含了类信息，描述了如何配置他们，以及如何相互调用</p>
<h3 id="3-5-Spring基于xml注入bean的几种方式"><a href="#3-5-Spring基于xml注入bean的几种方式" class="headerlink" title="3.5 Spring基于xml注入bean的几种方式"></a>3.5 Spring基于xml注入bean的几种方式</h3><ul>
<li>Set方法注入</li>
<li>构造器注入：通过index设置参数的位置；通过type设置参数类型</li>
<li>静态工厂注入</li>
<li>实例工厂</li>
</ul>
<h3 id="3-6-你怎样定义类的作用域？"><a href="#3-6-你怎样定义类的作用域？" class="headerlink" title="3.6 你怎样定义类的作用域？"></a>3.6 你怎样定义类的作用域？</h3><p>当定义一个在Spring里，我们还能给这个bean声明一个作用域。他可以通过bean定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的beam实例，bean的scope属性被制定为prototype。另外一方面，一个bean每次使用时候必须返回同一个实例，这个bean的scope属性必须设置为singleton。</p>
<h3 id="3-7-解释Spring支持的几种bean的作用域"><a href="#3-7-解释Spring支持的几种bean的作用域" class="headerlink" title="3.7 解释Spring支持的几种bean的作用域"></a>3.7 解释Spring支持的几种bean的作用域</h3><p>Spring框架支持以下五种bean的作用域：</p>
<ul>
<li>singleton：bean在每个Spring IoC容器中只有一个实例</li>
<li>prototype：一个bean的定义可以有多个实例</li>
<li>request：每次http请求都会创建一个bean，该作用域仅在基于 web的Spring ApplicationContext情形下有效</li>
<li>session：在一个http session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效</li>
<li>global-session：在一个全局的http session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
</blockquote>
<h3 id="3-8-Spring框架中能够的单利bean是线程安全的吗？"><a href="#3-8-Spring框架中能够的单利bean是线程安全的吗？" class="headerlink" title="3.8 Spring框架中能够的单利bean是线程安全的吗？"></a>3.8 Spring框架中能够的单利bean是线程安全的吗？</h3><p>不是，Spring框架中的案例bean不是县城内安全的</p>
<p>Spring中的bean默认是单例模式，spring框架并没有对单例bean进行多线程的封装处理。</p>
<p>实际上大部分时候spring bean是无状态的(比如dao类)，所以某种程度上来说bean也是线程安全的，但如果bean有状态的话(比如view model对象)，那就要求开发者自己去保证线程安全了，最简单的就是改变bean的作用域，把“singleton”变更为”prototype“，这样请求bean相当于new Bean()了，所以可以保证线程安全了。</p>
<ul>
<li>有状态就是有数据存储功能</li>
<li>无状态就是不会保存数据</li>
</ul>
<h3 id="3-9-Spring如何处理线程并发问题？"><a href="#3-9-Spring如何处理线程并发问题？" class="headerlink" title="3.9 Spring如何处理线程并发问题？"></a>3.9 Spring如何处理线程并发问题？</h3><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p>
<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal才用了“空间换时间”的方式。</p>
<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<h3 id="3-10-解释Spring框架中bean的生命周期"><a href="#3-10-解释Spring框架中bean的生命周期" class="headerlink" title="3.10 解释Spring框架中bean的生命周期"></a>3.10 解释Spring框架中bean的生命周期</h3><p>在传统的Java应用中，bean的生命 周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收，相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。</p>
<p>下图展示了bean装载到Spring应用上下文的一个典型的生命周期过程。</p>
<p><img src="./images/loading.gif" data-original="../images/posts/spring%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p>
<p>bean在spring容器中从创建到销毁经历了若干阶段，每一个阶段都可以针对Spring如何管理bean济宁个性化定制。</p>
<p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤：</p>
<p>Spring对bean进行实例化；</p>
<p>Spring将值和bean的引用注入到bean对应的属性中；</p>
<p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递setBean-Name()方法；</p>
<p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器 实例传入；</p>
<p>如果Bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用 传入进行；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p>
<p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</p>
<p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p>
<p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
<p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p>
<p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。  </p>
<h3 id="3-11-哪些是重要的bean生命周期方法？你能重载它们吗？"><a href="#3-11-哪些是重要的bean生命周期方法？你能重载它们吗？" class="headerlink" title="3.11 哪些是重要的bean生命周期方法？你能重载它们吗？"></a>3.11 哪些是重要的bean生命周期方法？你能重载它们吗？</h3><p>有两个重要的bean生命周期方法，第一个setup，它是在容器加载bean的时候被调用。第二个方法时teardown，它是在容器卸载类的时候被调用。</p>
<p>bean标签有两个重要的属性<code>(init-method和destroy-method)</code>。用它们你可以自己定制初始化和注销方法。它们也有相应的注解<code>@PostConstruct和@PreDestroy</code>。</p>
<h3 id="3-12-什么是Spring的内部bean？什么是Spring-inner-beans？"><a href="#3-12-什么是Spring的内部bean？什么是Spring-inner-beans？" class="headerlink" title="3.12 什么是Spring的内部bean？什么是Spring inner beans？"></a>3.12 什么是Spring的内部bean？什么是Spring inner beans？</h3><p>在Spring矿浆中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的。它们的Scope一般是prototype。</p>
<p>比如，在 我们的应用程序中，一个Customer类引用了一个Person类，我们要做的是创建一个Person的实例，然后在Customer内部使用。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span><span class="token punctuation">{</span>
     <span class="token keyword">private</span> Person person<span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">//Setters and Getters</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
     <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
     <span class="token keyword">private</span> String address<span class="token punctuation">;</span>
     <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">//Setters and Getters</span>
<span class="token punctuation">}</span></code></pre>
<p>内部bean的声明方式如下：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CustomerBean<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.somnus.common.Customer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
     <span class="token comment" spellcheck="true">&lt;!-- This is inner bean --></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.howtodoinjava.common.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lokesh<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>India<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>34<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre>
<h3 id="3-12-在Spring中如何注入一个java集合？"><a href="#3-12-在Spring中如何注入一个java集合？" class="headerlink" title="3.12 在Spring中如何注入一个java集合？"></a>3.12 在Spring中如何注入一个java集合？</h3><p>Spring提供以下及中欧冠集合的配置元素：</p>
<ul>
<li>类型用于注入一列值，允许有相同的值。</li>
<li>类型用于注入一组值，不允许有相同的值。</li>
<li>类型用于注入一组键值对，键和值都可以为任意类型。</li>
<li>类型用于注入一组键值对，键和值都只能为String类型。</li>
</ul>
<h3 id="3-13-什么是bean装配？"><a href="#3-13-什么是bean装配？" class="headerlink" title="3.13 什么是bean装配？"></a>3.13 什么是bean装配？</h3><p>装配，或bean装配是指在Spring容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p>
<h3 id="3-14-什么是bean的自动装配？"><a href="#3-14-什么是bean的自动装配？" class="headerlink" title="3.14 什么是bean的自动装配？"></a>3.14 什么是bean的自动装配？</h3><p>在Spring框架中，在配置文件中设定bean的依赖关系 是一个很好的机制，Spring容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着SPring可以通过向BeanFactory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p>
<h3 id="3-15-解释不通方式的自动装配，Spring自动-装配bean有哪些方式？"><a href="#3-15-解释不通方式的自动装配，Spring自动-装配bean有哪些方式？" class="headerlink" title="3.15 解释不通方式的自动装配，Spring自动 装配bean有哪些方式？"></a>3.15 解释不通方式的自动装配，Spring自动 装配bean有哪些方式？</h3><p>在Spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
<p>在Spring框架xml中共有5种自动装配：</p>
<ul>
<li>no：默认的方式是不进行自动装配，通过手工设置ref属性来进行装配bean。</li>
<li>byName：通过bean的名称进行自动装配，如果一个bean的property与另一bean的name相同，就进行自动装配。</li>
<li>byType：通过参数的数据类型进行自动装配。</li>
<li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li>
<li>autodetect：自动探测，如果有构造 方法，通过construct的方式自动转配，否则使用byTyre的方式自动装配。</li>
</ul>
<h3 id="3-16-使用-Autowired注解自动装配的过程是怎样的？"><a href="#3-16-使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="3.16 使用@Autowired注解自动装配的过程是怎样的？"></a>3.16 使用@Autowired注解自动装配的过程是怎样的？</h3><p>使用@Autowired注解来自动装配制定的bean。在使用@Autowired注解之前需要在Spring配置文件中进行配置，<code>&lt;context:annotation-config/&gt;</code>。</p>
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p>
<ul>
<li>如果查询结果刚好为一个，就讲该bean装配给@Autowired制定的数据</li>
<li>如果查询的结果不止一个，那么@Autowired会根据名称来查找</li>
<li>如果上述查找的结果为空，那么会抛出异常。解决方法是，使用<code>required=false</code></li>
</ul>
<h3 id="3-17-自动装配有哪些局限性？"><a href="#3-17-自动装配有哪些局限性？" class="headerlink" title="3.17 自动装配有哪些局限性？"></a>3.17 自动装配有哪些局限性？</h3><p>自动装配的局限性是：</p>
<p><strong>重写</strong>：你仍需用配置来定义依赖，意味着总要重写自动装配</p>
<p><strong>基本数据类型</strong>：不能 自动装配简单的属性，如基本数据类型、String字符串和类</p>
<p><strong>模糊特性</strong>：自动装配不如显示装配精确，如果有可能，建议使用显示装配</p>
<h3 id="3-18-可以在Spring中注入一个null和一个空字符串吗？"><a href="#3-18-可以在Spring中注入一个null和一个空字符串吗？" class="headerlink" title="3.18 可以在Spring中注入一个null和一个空字符串吗？"></a>3.18 可以在Spring中注入一个null和一个空字符串吗？</h3><p>可以</p>
<h2 id="4-Spring-注解"><a href="#4-Spring-注解" class="headerlink" title="4. Spring 注解"></a>4. Spring 注解</h2><h3 id="4-1-什么是基于java的Spring注解配置？给一些注解的例子"><a href="#4-1-什么是基于java的Spring注解配置？给一些注解的例子" class="headerlink" title="4.1 什么是基于java的Spring注解配置？给一些注解的例子"></a>4.1 什么是基于java的Spring注解配置？给一些注解的例子</h3><p>基于Java的配置，允许我们在少量的Java注解的帮助下，进行你的大部分SPring配置而非通过XML文件。</p>
<p>以<code>@Configuration</code>注解为例，它用来标记类可以当做一个bean的定义，被Spring IoC容器使用</p>
<p>另外一个例子是<code>@Bean</code>注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文中。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>    
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> StudentBean <span class="token function">myStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StudentBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="4-2-怎样开启注解装配？"><a href="#4-2-怎样开启注解装配？" class="headerlink" title="4.2 怎样开启注解装配？"></a>4.2 怎样开启注解装配？</h3><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置<code>&lt;context:annotation-config/&gt;</code>元素。</p>
<h3 id="4-3-Component-Controller-Repository-Service-有何区别？"><a href="#4-3-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="4.3 @Component, @Controller, @Repository, @Service 有何区别？"></a>4.3 @Component, @Controller, @Repository, @Service 有何区别？</h3><p><code>@Component</code>：它将java类标记为bean。它是任何Spring管理组件的通用构造性。Spring的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p>
<p><code>@Controller</code>：这将一个类标记为Spring Web MVC控制器。标有它的bean会自动导入到IoC容器中。</p>
<p><code>@Repository</code>：这个注解是具有类似用途和功能的@Component注解的特化。它为DAO提供了额外的好处。它将DAO导入IoC容器，并使未经检查的异常有资格转换为Spring DataAccessException。</p>
<p><code>@Service</code>：此注解是组件注解的特化。它不会对@Component注解提供任何其他行为。可以在服务层类中使用@Service 而不是@Component，因为它以更好的方式指定了意图。</p>
<h3 id="4-4-Required-注解有什么作用？"><a href="#4-4-Required-注解有什么作用？" class="headerlink" title="4.4 @Required 注解有什么作用？"></a>4.4 @Required 注解有什么作用？</h3><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若<code>@Required</code>注解的<code>bean属性未被设置</code>，容器将抛出<code>BeanInitializationException</code>。</p>
<p>示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Required</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> string <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="4-5-Autowired-注解有什么作用"><a href="#4-5-Autowired-注解有什么作用" class="headerlink" title="4.5 @Autowired 注解有什么作用?"></a>4.5 @Autowired 注解有什么作用?</h3><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> string <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="4-6-Autowired和-Resource之间的区别"><a href="#4-6-Autowired和-Resource之间的区别" class="headerlink" title="4.6 @Autowired和@Resource之间的区别"></a>4.6 @Autowired和@Resource之间的区别</h3><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>
<p>@Autowired和@Resource之间的区别</p>
<ul>
<li><p>@Autowired默认是按照<code>类型</code>装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p>
</li>
<li><p>@Resource默认是按照<code>名称</code>来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p>
</li>
</ul>
<h3 id="4-7-Qualifier-注解有什么作用"><a href="#4-7-Qualifier-注解有什么作用" class="headerlink" title="4.7 @Qualifier 注解有什么作用"></a>4.7 @Qualifier 注解有什么作用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<h3 id="4-8-RequestMapping-注解有什么用？"><a href="#4-8-RequestMapping-注解有什么用？" class="headerlink" title="4.8 @RequestMapping 注解有什么用？"></a>4.8 @RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h2 id="5-Spring数据访问"><a href="#5-Spring数据访问" class="headerlink" title="5. Spring数据访问"></a>5. Spring数据访问</h2><h3 id="5-1-请解释对象-关系映射集成模块"><a href="#5-1-请解释对象-关系映射集成模块" class="headerlink" title="5.1 请解释对象/关系映射集成模块"></a>5.1 请解释对象/关系映射集成模块</h3><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p>
<h3 id="5-2-在Spring框架中如何更有效地使用JDBC？"><a href="#5-2-在Spring框架中如何更有效地使用JDBC？" class="headerlink" title="5.2 在Spring框架中如何更有效地使用JDBC？"></a>5.2 在Spring框架中如何更有效地使用JDBC？</h3><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate。</p>
<h3 id="5-3-解释JDBC抽象和DAO模块"><a href="#5-3-解释JDBC抽象和DAO模块" class="headerlink" title="5.3 解释JDBC抽象和DAO模块"></a>5.3 解释JDBC抽象和DAO模块</h3><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p>
<h3 id="5-4-spring-DAO-有什么用？"><a href="#5-4-spring-DAO-有什么用？" class="headerlink" title="5.4 spring DAO 有什么用？"></a>5.4 spring DAO 有什么用？</h3><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h3 id="5-5-spring-JDBC-API-中存在哪些类？"><a href="#5-5-spring-JDBC-API-中存在哪些类？" class="headerlink" title="5.5 spring JDBC API 中存在哪些类？"></a>5.5 spring JDBC API 中存在哪些类？</h3><p>JdbcTemplate</p>
<p>SimpleJdbcTemplate</p>
<p>NamedParameterJdbcTemplate</p>
<p>SimpleJdbcInsert</p>
<p>SimpleJdbcCall</p>
<h3 id="5-6-JdbcTemplate是什么"><a href="#5-6-JdbcTemplate是什么" class="headerlink" title="5.6 JdbcTemplate是什么"></a>5.6 JdbcTemplate是什么</h3><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<h3 id="5-7-使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#5-7-使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="5.7 使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？"></a>5.7 使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>在Spring中有两种方式访问Hibernate：</p>
<ul>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ul>
<h3 id="5-8-如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"><a href="#5-8-如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="headerlink" title="5.8 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"></a>5.8 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h3><p>用Spring的 SessionFactory 调用 LocalSessionFactory。<br>集成过程分三步：</p>
<ul>
<li>配置the Hibernate SessionFactory</li>
<li>继承HibernateDaoSupport实现一个DAO</li>
<li>在AOP支持的事务中装配</li>
</ul>
<h3 id="5-9-Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#5-9-Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="5.9 Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>5.9 Spring支持的事务管理类型， spring 事务实现方式有哪些？</h3><p>Spring支持两种类型的事务管理：<br><code>编程式事务管理</code>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。<br><code>声明式事务管理</code>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>
<h3 id="5-10-Spring事务的实现方式和实现原理"><a href="#5-10-Spring事务的实现方式和实现原理" class="headerlink" title="5.10 Spring事务的实现方式和实现原理"></a>5.10 Spring事务的实现方式和实现原理</h3><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p>
<h3 id="5-11-说一下Spring的事务传播行为"><a href="#5-11-说一下Spring的事务传播行为" class="headerlink" title="5.11 说一下Spring的事务传播行为"></a>5.11 说一下Spring的事务传播行为</h3><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p>
<ol>
<li><p><code>PROPAGATION_REQUIRED</code>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>
</li>
<li><p><code>PROPAGATION_SUPPORTS</code>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>
</li>
<li><p><code>PROPAGATION_MANDATORY</code>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>
</li>
<li><p><code>PROPAGATION_REQUIRES_NEW</code>：创建新事务，无论当前存不存在事务，都创建新事务。</p>
</li>
<li><p><code>PROPAGATION_NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
</li>
<li><p><code>OPAGATION_NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常。</p>
</li>
<li><p><code>OPAGATION_NESTED</code>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>
</li>
</ol>
<h3 id="5-12-说一下-spring-的事务隔离？"><a href="#5-12-说一下-spring-的事务隔离？" class="headerlink" title="5.12 说一下 spring 的事务隔离？"></a>5.12 说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别，默认值为<code>ISOLATION_DEFAULT（使用数据库的设置）</code>，其他四个隔离级别和数据库的隔离级别一致：</p>
<ol>
<li><p><code>ISOLATION_DEFAULT</code>：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
</li>
<li><p><code>ISOLATION_READ_UNCOMMITTED</code>：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
</li>
<li><p><code>ISOLATION_READ_COMMITTED</code>：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p>
</li>
<li><p><code>ISOLATION_REPEATABLE_READ</code>：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
</li>
<li><p><code>ISOLATION_SERIALIZABLE</code>：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
</li>
</ol>
<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>*<em>不可重复读 *</em>：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h3 id="5-13-Spring框架的事务管理有哪些优点？"><a href="#5-13-Spring框架的事务管理有哪些优点？" class="headerlink" title="5.13 Spring框架的事务管理有哪些优点？"></a>5.13 Spring框架的事务管理有哪些优点？</h3><ul>
<li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li>
<li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API</li>
<li>支持声明式事务管理。</li>
<li>和Spring各种数据访问抽象层很好得集成。</li>
</ul>
<h3 id="5-14-你更倾向用那种事务管理类型？"><a href="#5-14-你更倾向用那种事务管理类型？" class="headerlink" title="5.14 你更倾向用那种事务管理类型？"></a>5.14 你更倾向用那种事务管理类型？</h3><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h2 id="6-Spring面向切面编程-AOP"><a href="#6-Spring面向切面编程-AOP" class="headerlink" title="6. Spring面向切面编程(AOP)"></a>6. Spring面向切面编程(AOP)</h2><h3 id="6-1-什么是AOP"><a href="#6-1-什么是AOP" class="headerlink" title="6.1 什么是AOP"></a>6.1 什么是AOP</h3><p><code>OOP(Object-Oriented Programming)面向对象编程</code>，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p><code>AOP(Aspect-Oriented Programming)</code>，一般称为<code>面向切面编程</code>，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p>
<h3 id="6-2-Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？"><a href="#6-2-Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？" class="headerlink" title="6.2 Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？"></a>6.2 Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h3><p>AOP实现的关键在于 <code>代理模式</code>，AOP代理主要分为<code>静态代理</code>和<code>动态代理</code>。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<p>（1）<code>AspectJ是静态代理的增强</code>，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>（2）<code>Spring AOP使用的动态代理</code>，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<h3 id="6-3-JDK动态代理和CGLIB动态代理的区别"><a href="#6-3-JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="6.3 JDK动态代理和CGLIB动态代理的区别"></a>6.3 JDK动态代理和CGLIB动态代理的区别</h3><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>
<ul>
<li><p>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</p>
</li>
<li><p>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
</li>
</ul>
<p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<blockquote>
<p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p>
</blockquote>
<h3 id="6-4-如何理解-Spring-中的代理？"><a href="#6-4-如何理解-Spring-中的代理？" class="headerlink" title="6.4 如何理解 Spring 中的代理？"></a>6.4 如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>
<p>Advice + Target Object = Proxy</p>
<h3 id="6-5-解释一下Spring-AOP里面的几个名词"><a href="#6-5-解释一下Spring-AOP里面的几个名词" class="headerlink" title="6.5 解释一下Spring AOP里面的几个名词"></a>6.5 解释一下Spring AOP里面的几个名词</h3><p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>
<p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p>
<p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p>
<p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p>
<p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p>
<p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p>
<p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p>
<ul>
<li><p>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</p>
</li>
<li><p>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应</p>
</li>
<li><p>用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</p>
</li>
<li><p>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</p>
</li>
</ul>
<h3 id="6-6-Spring在运行时通知对象"><a href="#6-6-Spring在运行时通知对象" class="headerlink" title="6.6 Spring在运行时通知对象"></a>6.6 Spring在运行时通知对象</h3><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p>
<p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p>
<h3 id="6-7-Spring只支持方法级别的连接点"><a href="#6-7-Spring只支持方法级别的连接点" class="headerlink" title="6.7 Spring只支持方法级别的连接点"></a>6.7 Spring只支持方法级别的连接点</h3><p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p>
<h3 id="6-8-在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#6-8-在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="6.8 在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>6.8 在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h3><p><code>关注点（concern）</code>是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p>
<p><code>横切关注点（cross-cutting concern）</code>是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h3 id="6-9-Spring通知有哪些类型？"><a href="#6-9-Spring通知有哪些类型？" class="headerlink" title="6.9 Spring通知有哪些类型？"></a>6.9 Spring通知有哪些类型？</h3><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>
<p>Spring切面可以应用5种类型的通知：</p>
<ol>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>
<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>
<li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li>
<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ol>
<blockquote>
<p>同一个aspect，不同advice的执行顺序：<br><code>没有异常情况下的执行顺序：</code><br>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning</p>
<p><code>有异常情况下的执行顺序：</code></p>
<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p>
</blockquote>
<h3 id="6-10-什么是切面-Aspect？"><a href="#6-10-什么是切面-Aspect？" class="headerlink" title="6.10 什么是切面 Aspect？"></a>6.10 什么是切面 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ul>
<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>
<li>如何在 advice 中编写切面代码.</li>
</ul>
<p>可以简单地认为, 使用 @Aspect 注解的类就是切面.</p>
<p><img src="./images/loading.gif" data-original="../images/posts/spring%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/Aspect.png" alt=""></p>
<h3 id="6-11-解释基于XML-Schema方式的切面实现"><a href="#6-11-解释基于XML-Schema方式的切面实现" class="headerlink" title="6.11 解释基于XML Schema方式的切面实现"></a>6.11 解释基于XML Schema方式的切面实现</h3><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p>
<h3 id="6-12-解释基于注解的切面实现"><a href="#6-12-解释基于注解的切面实现" class="headerlink" title="6.12 解释基于注解的切面实现"></a>6.12 解释基于注解的切面实现</h3><p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p>
<h3 id="6-13-有几种不同类型的自动代理？"><a href="#6-13-有几种不同类型的自动代理？" class="headerlink" title="6.13 有几种不同类型的自动代理？"></a>6.13 有几种不同类型的自动代理？</h3><p>BeanNameAutoProxyCreator</p>
<p>DefaultAdvisorAutoProxyCreator</p>
<p>Metadata autoproxying</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://fyvan.github.io/undefined/e999.html" title="spring面试整理" target="_blank" rel="external">http://fyvan.github.io/undefined/e999.html</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="./images/loading.gif" data-original="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark">昵称</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/undefined/1529.html" title="面试之性能优化"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="./images/loading.gif" data-original="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="./images/loading.gif" data-original="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>